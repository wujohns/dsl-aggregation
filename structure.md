# 结构整理
在进入到后续的章节之前，这里先对低代码平台或是CMS框架核心部分结构的设计思路做一次整理，以便于对整体结构有一个了解，以及在后续工作中区分和定位需要重点关注的部分。

## 总体结构一览
从数据处理的角度来看，对于一个完整的应用来说，其主要结构如下图所示：  
![base-struc](/img/base-struc.png)

为了更便捷的产出对应的应用，低代码平台以如下图所示的策略进行了支撑： 
![detail-struc](/img/detail-struc.png)

需要注意的是：
> 1. 这里是按照功能为依据进行划分的，为了更贴合用户的需求，大部分的低代码平台采取的是将 `Model Panel`、`Query Panel`、`Write Panel`、`UI Panel` 做了适当的融合（界限没有如上图所示的那么分割开来）  
> 1. 为了后续的细化研究，这里将原本融合在一起的设计进行拆分，以便于理解对应的设计细节

## 产品策略
在上述中，我们将低代码平台所作的工作以下功能板块做了划分：  
> `Model Panel` --- 数据结构配置面板  
> `Query Panel` --- 数据读出逻辑配置面板  
> `Write Panel` --- 数据写入逻辑配置面板  
> `UI Panel` --- UI 界面的可视化编辑面板

这里以 `简道云` 为例，简略讲解一下其对上述功能板块的处理策略
![jdy-form](/img/jdy/form.png)

此处是 `简道云` 使用中的表单配置截图，如图所示 `简道云` 此处采取的产品策略是将 `Model Panel` 与 `UI Panel` 进行了融合与适配以实现所见即所得的使用体验，用户在配置对应 `表单属性/字段属性` 时同时完成了 `数据结构（Model）` 与 `数据输入依赖的页面（UI）` 两者的配置。

除此之外 `简道云` 在：  
`仪表盘` 部分采取了 `Query Panel` 与 `UI Panel` 的融合策略  
`流程表单部分` 部分采取了 `Write Panel` 与 `UI Panel` 的融合策略

这些策略都有效降低了用户构建目标产品的心智成本，也是其在该领域获得成果的关键

> 该部分只是对结构做一个简要的分析，主要是阐述笔者对低代码平台解析的思考方式，在 `案例解析` 章节对不同的产品与框架做详细的分析

## 演进思路
![build](/img/build.png)

如上图所示，在笔者推进自身需要的低代码工具时经历了如上图所示的演进过程，即：  
>1. 遇到需要写很多重复代码的业务逻辑  
>1. 开始写一些依据配置自动生成代码的工具脚本，生成后直接进行复制粘贴  
>1. 发现即使复制粘贴也占用了大部分的时间，并且属于人工操作容易出错  
>1. 制定对应的 `metaData` 规范，并编写UI管理面板实现该部分的可视化管理  

在经历上述的步骤后，即自然得到了一个可满足自身业务方向的低代码平台  
需要注意的是，上述的演进方式每一步操作都可以从前一步中获取即时的反馈，相比于直接构建设计目标低代码平台在研发治理上会更为平滑（即避免平地起高楼带来的研发困境）

## 设计陷阱汇总
在处理对应的业务逻辑，推进自己的低代码工具，以及对已有的工具和框架进行调研时，走过一些弯路与误区，这里对这些误区做一个简要的汇总：  

### 复杂度代价只可转移无法降低
简单来说，这一条就是经典的 `没有银弹`，业务本身的复杂度并不会因为你使用工具的不同而降低，即使是使用 `低代码平台` 或是 `无代码平台` 在解决对应的业务时也需要工程思路/方法

### 不要忽略较高收益的伪银弹
虽然没有 `完美的银弹` 但 `低代码平台` 或是 `无代码平台` 却是解决业务逻辑的 `伪银弹`，在特定的场景下是极其有效的，因为：  
1. 降低了参与业务逻辑制定的预备技术门槛，使之只用关心业务逻辑本身  
1. 由于1，使得在人员要求上可以放宽很多，在工程量较多时可以有较大的增益  
1. 加快项目速度，减少成本  

### 缺乏有效的反馈机制会导致研发困境
部分 `团队/公司` 在推进对应的 `低代码平台` 时采用的是平地起高楼的方式，该方式忽略了 `低代码平台` 建设的长周期以及高成本，在漫长的研发周期中将很难建立较为有效的渠道获取实际最终服务目标的反馈，导致研发困境。

所以在推进该类平台时，最好是从已有的成熟业务逻辑中获得反馈，或是按照上述的演进思路，逐步迭代抽象到最终的 `低代码平台`，否则将较容易在产研方向上走偏

### 避免定制化代码脱离上下文支援（华炎魔方部分）
在 `低代码平台` 中，为了提供更高的自定义特性，通常会采用 `eval/vm` 的方式引入 `低代码平台` 母语言的拓展支持，但该类支持能获得的拓展性往往十分有限（例如支持嵌入 `js`，但该嵌入的 `js` 又不能引入第三方包或是 `低代码平台` 本身能力的支援），使得该部分的处理十分鸡肋

在对 `华炎魔方` 的分析中将会详细解析，这也是为什么采用 `DSL` 支援自定义部分的原因

## Why DSL
// TODO 该部分需要继续思考，并在之后安排到其他章节
// 明确设计目标以及设计缘由  
// 为什么不使用 eval/vm 模式（变量注入困难/基础设施无法复用）  
